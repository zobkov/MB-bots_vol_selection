# Архитектура бота

## Общая структура

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Telegram      │    │   Bot Process   │    │   Database      │
│   Bot API       │◄──►│                 │◄──►│   PostgreSQL    │
└─────────────────┘    │   ┌─────────────┤    └─────────────────┘
                       │   │ aiogram 3.x │    
                       │   └─────────────┤    ┌─────────────────┐
                       │   ┌─────────────┤    │   Redis         │
                       │   │ aiogram-    │◄──►│   (FSM Storage) │
                       │   │ dialog      │    └─────────────────┘
                       │   └─────────────┤
                       └─────────────────┘
```

## Компоненты

### 1. Telegram Bot (aiogram 3.x)
- **Роль**: Основной фреймворк для работы с Telegram API
- **Функции**: 
  - Обработка сообщений и команд
  - Управление состояниями пользователей
  - Отправка ответов

### 2. Dialog System (aiogram-dialog)
- **Роль**: Система диалогов для построения интерфейса
- **Функции**:
  - Управление окнами и переходами
  - Обработка пользовательского ввода
  - Отображение динамического контента

### 3. Database Layer (SQLAlchemy + asyncpg)
- **Роль**: Работа с данными
- **Компоненты**:
  - `models.py` - определения таблиц
  - `repositories.py` - бизнес-логика работы с данными
  - `db.py` - подключение и сессии

### 4. FSM Storage (Redis)
- **Роль**: Хранение состояний конечного автомата
- **Функции**:
  - Сохранение текущего состояния пользователя
  - Хранение временных данных диалогов
  - Быстрый доступ к данным сессии

### 5. Configuration System
- **Роль**: Централизованное управление настройками
- **Компоненты**:
  - `config.py` - загрузка из переменных окружения
  - `selection_config.json` - настройки этапов отбора

## Поток данных

### Пользователь заполняет анкету:

1. **Пользователь** отправляет `/start`
2. **aiogram** получает сообщение
3. **Handler** направляет в StartSG.start
4. **aiogram-dialog** отображает стартовое окно
5. **Пользователь** нажимает кнопку → MenuSG.main
6. **Пользователь** нажимает "Заполнить анкету" → ApplicationSG.full_name
7. **aiogram-dialog** последовательно собирает данные в dialog_data
8. При переходе к отделам → DepartmentSelectionSG (новый стек)
9. После завершения выбора → возврат в ApplicationSG.motivation
10. **Repository** сохраняет данные в PostgreSQL
11. **User status** обновляется на "submitted"

### Диаграмма состояний:

```
StartSG.start ──────────► MenuSG.main
                            │
                            ▼
                       MenuSG.support
                            │
                            ▼
                    ApplicationSG.full_name
                            │
                            ▼
                    ApplicationSG.course
                            │
                            ▼
                          ...
                            │
                            ▼
                    ApplicationSG.departments
                            │
                            ▼
                    DepartmentSelectionSG.*
                            │
                            ▼ (return result)
                    ApplicationSG.motivation
                            │
                            ▼
                    ApplicationSG.overview
                            │
                            ▼ (save to DB)
                       MenuSG.main
```

## Безопасность

### Валидация данных
- Email проверяется на домен @spbu.ru
- Телефон принимается только через Telegram Contact
- Все пользовательские данные экранируются

### База данных
- Использование параметризованных запросов (SQLAlchemy ORM)
- Async подключения для производительности
- Миграции для версионирования схемы

### Конфигурация
- Секретные данные только в переменных окружения
- Настройки этапов в отдельном JSON файле
- Google credentials в отдельном файле (опционально)

## Масштабирование

### Горизонтальное
- Redis может быть кластеризован
- PostgreSQL поддерживает replication
- Bot процесс stateless (кроме Redis)

### Мониторинг
- Логирование через Python logging
- Метрики подключений к БД
- Мониторинг использования Redis

### Производительность
- Async/await везде где возможно
- Connection pooling для PostgreSQL
- Lazy loading данных в диалогах
